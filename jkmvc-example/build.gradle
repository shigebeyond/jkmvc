dependencies{
    // other project
    if(env == 'dev') {
        compile project(':jkmvc-http')
        compile project(':jkmvc-server-jetty')
    }else{
        compile "net.jkcode.jkmvc:jkmvc-http:${project.version}"
        compile "net.jkcode.jkmvc:jkmvc-server-jetty:${project.version}"
    }

    /*
     * JettyServerLauncher 启动时报错: `java.lang.NoClassDefFoundError: javax/servlet/ServletRequest`
     * 原因: gradle的 war 插件自动将 javax.servlet-api 弄成 providedCompile, 你就算在工程的build.gradle 改为 compile 也没用
     * fix: project structure -> modules -> 选中 JettyServerLauncher 应用的工程 -> depencies -> 选中 Gradle: javax.servlet:javax.servlet-api:3.1.0 包, 将 scop 由 provided 改为 compile
     */
    //compile "javax.servlet:javax.servlet-api:3.1.0"

    // jdbc
    runtime "mysql:mysql-connector-java:5.1.6"
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version"
}

apply plugin: 'war'
apply plugin: 'org.akhikhl.gretty'

// 复制start.sh
task copyStartSh(type: Copy) {
    into "${buildDir}/libs"
    from "start-jetty.sh"
}
build.dependsOn(copyStartSh)

// 启动jetty
gretty{
    // server 配置
    servletContainer 'jetty9' // 'tomcat8'
    httpPort 8080
    managedClassReload true // 热部署
    scanInterval 1 // 热部署的扫描间隔，当值为0时，不扫描新class，不热部署

    // 调试: gradle appRunDebug
    debugPort 5006 // 运行jetty的jvm独立于运行gradle的jvm, 因此也使用独立的调试端口
    debugSuspend true

    // webapp 配置
    contextPath "/${project.name}"
    inplaceMode "hard" // 资源目录 src/main/webapp
}